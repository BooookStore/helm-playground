jacksonについて調べたときのメモその２です。

環境は前回の記事と同じですので省略します。

https://baubaubau.hatenablog.com/entry/2024/02/04/145625

TreeModelというものがどうやらあるらしいので触ってみましょう。

https://github.com/FasterXML/jackson-databind?tab=readme-ov-file#tree-model

一応wikiにもページがありましたが中身が空っぽのようです。

https://github.com/FasterXML/jackson-databind/wiki/JacksonTreeModel

## TreeModel

jacksonを使うとJavaのオブジェクトとJSONまたは、ListやMapなどのコレクションなどとJSONとの間で相互変換ができますが、JSONをトラバーサルするのには向いていません。ということでTreeModelというものがあるぞ、というみたいです。

ObjectMapperをインスタンス化し、

``` java
ObjectMapper objectMapper = new ObjectMapper();
```

readTreeでJSON文字列を読み込みます。するとJSONのルート要素を表現するJsonNodeが返ってくるようです。

``` java
JsonNode root;

root = objectMapper.readTree("""
    {
        "NB001": {
            "profile": {
                "firstName": "book",
                "lastName": "store",
                "age": 25
            },
            "type": [
                "software engineer"
            ]
        }
    }
    """);
```

トラバーサルして値を読み込むにはgetを使い目的のプロパティまで掘っていけば良さそう。

値の型に応じてasなんちゃらメソッドを呼び出せば対応するJavaの値で取得できます。

``` java
String firstName = root.get("NB001").get("profile").get("firstName").asText();
assertEquals("book", firstName);

int age = root.get("NB001").get("profile").get("age").asInt();
assertEquals(25, age);
```

値がない場合、結果はnullになりました。

``` java
JsonNode notExist = root.get("notExist");
assertNull(notExist);
```

値と型が適切ではない場合も試してみました。

どうやら変換できるものは頑張ってくれますが、無理なものは無意味な値で取得されるようです。てっきり例外が発生するかと思いましたがそうではないみたい。

``` java
int firstName = root.get("NB001").get("profile").get("firstName").asInt();
assertEquals(0, firstName); // 本当は "book"

String age = root.get("NB001").get("profile").get("age").asText();
assertEquals("25", age); // 数値の25が文字列に変換された
```

値を取得する前に対象がどんな型なのかを確認するには、isなんちゃらのメソッドを使えば良さそうです。

``` java
JsonNode firstNameNode = root.get("NB001").get("profile").get("firstName");
assertTrue(firstNameNode.isTextual());
assertFalse(firstNameNode.isInt());

JsonNode ageNode = root.get("NB001").get("profile").get("age");
assertTrue(ageNode.isInt());
assertFalse(ageNode.isTextual());
```

トラバーサるしつつ、JSONの一部分をオブジェクトへマッピングできるようです。

次のようなクラスを定義し、

``` java
public record Profile(String firstName, String lastName, int age) {
}
```

treeToValueで読み込みます。

``` java
Profile profile = objectMapper.treeToValue(root.get("NB001").get("profile"), Profile.class);
assertEquals(new Profile("book", "store", 25), profile);
```

そういえば、jacksonはネストされた構造のJSONを読み込むとどうなるのでしょうか？

こういうクラスを用意し、

``` java
record ProfileNestedJson(String firstName, String lastName, int age, ProfileNestedJsonAddress address) {
}
                                                                                                        
record ProfileNestedJsonAddress(String country, String countryCode) {
}
```

以下のように読み込めました。

``` java
JsonNode root = objectMapper.readTree("""
        {
            "NB001": {
                "profile": {
                    "firstName": "book",
                    "lastName": "store",
                    "age": 25,
                    "address": {
                        "country": "Japan",
                        "countryCode": "JPN"
                    }
                },
                "type": [
                    "software engineer"
                ]
            }
        }
        """);

var profileNestedJson = objectMapper.treeToValue(root.get("NB001").get("profile"), ProfileNestedJson.class);
                                                                                                                          
assertEquals(new ProfileNestedJson("book", "store", 25, new ProfileNestedJsonAddress("Japan", "JPN")), profileNestedJson);
```